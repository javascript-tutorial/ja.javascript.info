
<<<<<<< HEAD
# ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«, å°å…¥

ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒå¤§ãããªã‚‹ã«ã¤ã‚Œã€ãã‚Œã‚’è¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«åˆ†å‰²ã—ãŸããªã‚Šã¾ã™ã€‚ã„ã‚ã‚†ã‚‹ 'ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«' ã§ã™ã€‚
é€šå¸¸ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã‚¯ãƒ©ã‚¹ã‚„ä¾¿åˆ©ãªé–¢æ•°ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’å«ã¿ã¾ã™ã€‚

é•·ã„é–“ã€JavaScript ã«ã¯è¨€èªãƒ¬ãƒ™ãƒ«ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æ–‡ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã§ã—ãŸã€‚å½“åˆã¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒå°ã•ãã¦å˜ç´”ã ã£ãŸãŸã‚ã€ãã‚Œã¯å•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ãã®ãŸã‚ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä»•çµ„ã¿ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚

ã—ã‹ã—ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆå¾ã€…ã«è¤‡é›‘ã«ãªã£ã¦ãã¾ã—ãŸã€‚ãã®ãŸã‚ã€ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¯ã‚³ãƒ¼ãƒ‰ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¾ã¨ã‚ã‚‹ãŸã‚ã®æ§˜ã€…ãªæ–¹æ³•ã‚’ç™ºæ˜ã—ã¾ã—ãŸã€‚

ä¾‹ãˆã°:

- [AMD](https://en.wikipedia.org/wiki/Asynchronous_module_definition) -- æœ€ã‚‚å¤ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®1ã¤ã§ã€æœ€åˆã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒª[require.js](http://requirejs.org/)ã§å®Ÿè£…ã•ã‚Œã¾ã—ãŸã€‚
- [CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1) -- Node.JS ã‚µãƒ¼ãƒç”¨ã«ä½œã‚‰ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚
- [UMD](https://github.com/umdjs/umd) -- ã‚‚ã†1ã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã§ã€ãƒ¦ãƒ‹ãƒãƒ¼ã‚µãƒ«ãªã‚‚ã®ã¨ã—ã¦ææ¡ˆã•ã‚Œã¦ã„ã¾ã™ã€‚AMD ã¨ CommonJS ã¨äº’æ›æ€§ãŒã‚ã‚Šã¾ã™ã€‚

ä»Šã‚„ã€ã“ã‚Œã‚‰ã¯ã‚†ã£ãã‚Šã¨æ­´å²ã®ä¸€éƒ¨ã«ãªã£ã¦ã„ã¾ã™ãŒã€ä¾ç„¶ã¨ã—ã¦å¤ã„ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ä¸­ã§åˆ©ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚è¨€èªãƒ¬ãƒ™ãƒ«ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®æ¨™æº–ã¯ 2015 å¹´ã«ç™»å ´ã—ã€ãã‚Œä»¥æ¥å¾ã€…ã«é€²åŒ–ã—ã€ä»Šã§ã¯ã™ã¹ã¦ã®ä¸»è¦ãªãƒ–ãƒ©ã‚¦ã‚¶ã¨Node.JS ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚

## ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã¯?

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å˜ãªã‚‹1ã¤ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚

ãƒ‡ã‚£ãƒ¬ã‚¯ãƒ†ã‚£ãƒ– `export` ã¨ `import` ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã§æ©Ÿèƒ½ã‚’ç›¸äº’ã«ã‚„ã‚Šã¨ã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚:

- `export` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å¤–éƒ¨ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã§ã‚ã‚‹ã¹ãå¤‰æ•°ã‚„é–¢æ•°ã«ãƒ©ãƒ™ãƒ«ä»˜ã‘ã‚’ã—ã¾ã™ã€‚
- `import` ã¯ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰æ©Ÿèƒ½ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

ä¾‹ãˆã°ã€é–¢æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ« `sayHi.js` ãŒã‚ã‚Šã¾ã™:
=======
# Modules, introduction

As our application grows bigger, we want to split it into multiple files, so called 'modules'.
A module usually contains a class or a library of useful functions.

For a long time, JavaScript existed without a language-level module syntax. That wasn't a problem, because initially scripts were small and simple, so there was no need.

But eventually scripts became more and more complex, so the community invented a variety of ways to organize code into modules, special libraries to load modules on demand.

For instance:

- [AMD](https://en.wikipedia.org/wiki/Asynchronous_module_definition) -- one of the most ancient module systems, initially implemented by the library [require.js](http://requirejs.org/).
- [CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1) -- the module system created for Node.js server.
- [UMD](https://github.com/umdjs/umd) -- one more module system, suggested as a universal one, compatible with AMD and CommonJS.

Now all these slowly become a part of history, but we still can find them in old scripts. The language-level module system appeared in the standard in 2015, gradually evolved since then, and is now supported by all major browsers and in Node.js.

## What is a module?

A module is just a file, a single script, as simple as that.

There are directives `export` and `import` to interchange functionality between modules, call functions of one module from another one:

- `export` keyword labels variables and functions that should be accessible from outside the current module.
- `import` allows to import functionality from other modules.

For instance, if we have a file `sayHi.js` exporting a function:
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```js
// ğŸ“ sayHi.js
export function sayHi(user) {
  alert(`Hello, ${user}!`);
}
```

<<<<<<< HEAD
...ãã—ã¦ã€åˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ãã‚Œã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ä½¿ã„ã¾ã™ã€‚:
=======
...Then another file may import and use it:
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```js
// ğŸ“ main.js
import {sayHi} from './sayHi.js';

alert(sayHi); // function...
sayHi('John'); // Hello, John!
```

<<<<<<< HEAD
ã“ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã§ã¯è¨€èªè‡ªèº«ã«ç„¦ç‚¹ã‚’å½“ã¦ã¦ã„ã¾ã™ãŒã€ãƒ‡ãƒ¢ç’°å¢ƒã¨ã—ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ãªã®ã§ã€ãƒ–ãƒ©ã‚¦ã‚¶ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‹•ä½œã•ã›ã‚‹æ–¹æ³•ã‚’è¦‹ã¦ãŠãã¾ã—ã‚‡ã†ã€‚

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã« `<script type="module">` å±æ€§ã‚’è¨­å®šã—ã¾ã™ã€‚:

[codetabs src="say" height="140" current="index.html"]

ãƒ–ãƒ©ã‚¦ã‚¶ã¯è‡ªå‹•çš„ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¯¾è±¡ã‚’å–å¾—/è©•ä¾¡ã—ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

## ã‚³ã‚¢ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç‰¹å¾´

"é€šå¸¸ã®" ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨æ¯”è¼ƒã—ã¦ã¨ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é•ã„ã¯ä½•ã§ã—ã‚‡ã†ï¼Ÿ

ãƒ–ãƒ©ã‚¦ã‚¶ã¨ã‚µãƒ¼ãƒã‚µã‚¤ãƒˆ JavaScript ã®ä¸¡æ–¹ã«æœ‰åŠ¹ãªã‚³ã‚¢ãªç‰¹å¾´ãŒã‚ã‚Šã¾ã™ã€‚

### å¸¸ã« "use strict"

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å¸¸ã« `use strict` ã§ã™ã€‚E.g. æœªå®£è¨€å¤‰æ•°ã¸ã®ä»£å…¥ã¯ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚
=======
In this tutorial we concentrate on the language itself, but we use browser as the demo environment, so let's see how to use modules in the browser.

As modules support special keywords and features, we must tell the browser that a script should be treated as module, by using the attribute `<script type="module">`.

Like this:

[codetabs src="say" height="140" current="index.html"]

The browser automatically fetches and evaluates imported modules, and then runs the script.

## Core module features

What's different in modules, compared to "regular" scripts?

There are core features, valid both for browser and server-side JavaScript.

### Always "use strict"

Modules always `use strict`, by default. E.g. assigning to an undeclared variable will give an error.
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```html run
<script type="module">
  a = 5; // error
</script>
```

<<<<<<< HEAD
ã“ã“ã§ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã§ç¢ºèªã—ã¦ã„ã¾ã™ãŒã€åŒã˜ã“ã¨ã¯ã©ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚‚å½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚

### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã®ã‚¹ã‚³ãƒ¼ãƒ—

å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ç‹¬è‡ªã®æœ€ä¸Šä½ã®ã‚¹ã‚³ãƒ¼ãƒ—ãŒã‚ã‚Šã¾ã™ã€‚ã¤ã¾ã‚Šã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®æœ€ä¸Šä½ã®å¤‰æ•°ã‚„é–¢æ•°ã¯ä»–ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‹ã‚‰ã¯è¦‹ãˆã¾ã›ã‚“ã€‚

ä¸‹ã®ä¾‹ã§ã¯ã€2ã¤ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ãŠã‚Šã€`hello.js` ã¯ `user.js` ã§å®£è¨€ã•ã‚Œã¦ã„ã‚‹å¤‰æ•° `user` ã‚’ä½¿ãŠã†ã¨ã—ã¦ã€å¤±æ•—ã—ã¾ã™:

[codetabs src="scopes" height="140" current="index.html"]

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€å¤–éƒ¨ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã«ã—ãŸã„ã‚‚ã®ã¯ `export` ã‚’ã—ã€å¿…è¦ãªã‚‚ã®ã¯ `import` ã™ã‚‹ã“ã¨ã‚’æœŸå¾…ã—ã¦ã„ã¾ã™ã€‚

ã—ãŸãŒã£ã¦ã€`index.html` ã®ä»£ã‚ã‚Šã«ã€ç›´æ¥ `hello.js` ã§ `user.js` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã“ã‚Œã¯æ­£ã—ã„ä¾‹ã§ã™:

[codetabs src="scopes-working" height="140" current="hello.js"]

ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã€å„ `<script type="module">` ã«å¯¾ã—ã¦ã‚‚ç‹¬ç«‹ã—ãŸæœ€ä¸Šä½ã‚¹ã‚³ãƒ¼ãƒ—ãŒå­˜åœ¨ã—ã¾ã™ã€‚:

```html run
<script type="module">
  // å¤‰æ•°ã¯ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ä¸­ã§ã®ã¿è¦‹ãˆã¾ã™
=======
Here we can see it in the browser, but the same is true for any module.

### Module-level scope

Each module has its own top-level scope. In other words, top-level variables and functions from a module are not seen in other scripts.

In the example below, two scripts are imported, and `hello.js` tries to use `user` variable declared in `user.js`, and fails:

[codetabs src="scopes" height="140" current="index.html"]

Modules are expected to `export` what they want to be accessible from outside and `import` what they need.

So we should import `user.js` directly into `hello.js` instead of `index.html`.

That's the correct variant:

[codetabs src="scopes-working" height="140" current="hello.js"]

In the browser, independent top-level scope also exists for each `<script type="module">`:

```html run
<script type="module">
  // The variable is only visible in this module script
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09
  let user = "John";
</script>

<script type="module">
  *!*
  alert(user); // Error: user is not defined
  */!*
</script>
```

<<<<<<< HEAD
ã‚‚ã—ã‚‚ã€æœ¬å½“ã« "ã‚°ãƒ­ãƒ¼ãƒãƒ«ãª" ãƒ–ãƒ©ã‚¦ã‚¶å†…å¤‰æ•°ã‚’ä½œã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€ãã‚Œã‚’æ˜ç¤ºçš„ã« `window` ã«å‰²ã‚Šå½“ã¦ã€`window.user` ã¨ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚ã—ã‹ã—ã€ã“ã‚Œã¯ä¾‹å¤–ã§ã‚ã‚Šæ­£å½“ãªç†ç”±ãŒã‚ã‚‹å ´åˆã®ã¿ã§ã™ã€‚

### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒ¼ãƒ‰ã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã®åˆå›ã«ã®ã¿è©•ä¾¡ã•ã‚Œã¾ã™

ã‚‚ã—åŒã˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¤‡æ•°ã®ä»–ã®å ´æ‰€ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹å ´åˆã€ãã®ã‚³ãƒ¼ãƒ‰ã¯åˆå›ã®ã¿å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãã®å¾Œã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ãŸã‚‚ã®ã¯ã™ã¹ã¦ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚

ã“ã‚Œã¯é‡è¦ãªçµæœã‚’ã‚‚ãŸã‚‰ã—ã¾ã™ã€‚ä¾‹ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

ã¾ãšã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹ã¨è¨€ã£ãŸã‚ˆã†ãªã€å‰¯ä½œç”¨ã‚’ã‚‚ãŸã‚‰ã™ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹å ´åˆã€è¤‡æ•°å›ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã‚‚ãƒˆãƒªã‚¬ã•ã‚Œã‚‹ã®ã¯1åº¦ã ã‘ã§ã™(åˆå›)ã€‚:
=======
If we really need to make a window-level global variable, we can explicitly assign it to `window` and access as `window.user`. But that's an exception requiring a good reason.

### A module code is evaluated only the first time when imported

If the same module is imported into multiple other places, its code is executed only the first time, then exports are given to all importers.

That has important consequences. Let's see that on examples.

First, if executing a module code brings side-effects, like showing a message, then importing it multiple times will trigger it only once -- the first time:
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```js
// ğŸ“ alert.js
alert("Module is evaluated!");
```

```js
<<<<<<< HEAD
// åˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰åŒã˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
=======
// Import the same module from different files
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

// ğŸ“ 1.js
import `./alert.js`; // Module is evaluated!

// ğŸ“ 2.js
import `./alert.js`; // (nothing)
```

<<<<<<< HEAD
å®Ÿéš›ã€æœ€ä¸Šä½ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒ¼ãƒ‰ã¯ä¸»ã«åˆæœŸåŒ–ã«ä½¿ã‚ã‚Œã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆã—ã€ãã‚Œã‚‰ã‚’äº‹å‰ã«è¨­å®šã—ã¾ã™ã€‚ãã—ã¦ã€ä½•ã‹ã‚’å†åˆ©ç”¨å¯èƒ½ã«ã—ãŸã„ã¨ãã€ãã‚Œã‚‰ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚

ã“ã‚Œã¯ã‚ˆã‚Šé«˜åº¦ãªä¾‹ã§ã™ã€‚

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã¨ã—ã¾ã—ã‚‡ã†:
=======
In practice, top-level module code is mostly used for initialization. We create data structures, pre-fill them, and if we want something to be reusable -- export it.

Now, a more advanced example.

Let's say, a module exports an object:
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```js
// ğŸ“ admin.js
export let admin = {
  name: "John"
};
```

<<<<<<< HEAD
ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸå ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯åˆå›ã«ã ã‘è©•ä¾¡ã•ã‚Œã€`admin` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿæˆã•ã‚Œã€ãã®å¾Œã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æ¸¡ã•ã‚Œã¾ã™ã€‚

ã™ã¹ã¦ã®ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã¯æ­£ç¢ºã«1ã¤ã® `admin` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚:
=======
If this module is imported from multiple files, the module is only evaluated the first time, `admin` object is created, and then passed to all further importers.

All importers get exactly the one and only `admin` object:
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```js
// ğŸ“ 1.js
import {admin} from './admin.js';
admin.name = "Pete";

// ğŸ“ 2.js
import {admin} from './admin.js';
alert(admin.name); // Pete

*!*
<<<<<<< HEAD
// 1.js ã¨ 2.js åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ
// 1.js ã§è¡Œã‚ã‚ŒãŸå¤‰æ›´ã¯ 2.js ã§ã‚‚è¦‹ãˆã¾ã™
*/!*
```

ç¹°ã‚Šè¿”ã—ã¾ã—ã‚‡ã† -- ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ä¸€åº¦ã ã‘å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãŒç”Ÿæˆã•ã‚Œã€ãã‚ŒãŒã‚¤ãƒ³ãƒãƒ¼ã‚¿é–“ã§å…±æœ‰ã•ã‚Œã¾ã™ã€‚ãã®ãŸã‚ã€ãªã«ã‹ãŒ `admin` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ã—ãŸå ´åˆã€ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚‚ãã®å¤‰æ›´ãŒè¦‹ãˆã¾ã™ã€‚

ã“ã®ã‚ˆã†ãªæŒ¯ã‚‹èˆã„ã¯ã€ã‚³ãƒ³ãƒ•ã‚£ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒå¿…è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¨ã£ã¦ã¯ä¾¿åˆ©ã§ã™ã€‚æœ€åˆã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§å¿…è¦ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®šã™ã‚‹ã“ã¨ãŒã§ãã€ä»¥é™ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ã¯ã™ã§ã«æº–å‚™ãŒã§ãã¦ã„ã‚‹çŠ¶æ…‹ã§ã™ã€‚

ä¾‹ãˆã°ã€`admin.js` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ç‰¹å®šã®æ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€å¤–éƒ¨ã‹ã‚‰ `admin` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«æƒ…å ±ãŒæ¥ã‚‹ã“ã¨ã‚’æœŸå¾…ã—ã¾ã™ã€‚:
=======
// Both 1.js and 2.js imported the same object
// Changes made in 1.js are visible in 2.js
*/!*
```

So, let's reiterate -- the module is executed only once. Exports are generated, and then they are shared between importers, so if something changes the `admin` object, other modules will see that .

Such behavior is great for modules that require configuration. We can set required properties on the first import, and then in further imports it's ready.

For instance, `admin.js` module may provide certain functionality, but expect the credentials to come into the `admin` object from outside:
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```js
// ğŸ“ admin.js
export let admin = { };

export function sayHi() {
  alert(`Ready to serve, ${admin.name}!`);
}
```

<<<<<<< HEAD
ã“ã“ã§ã€`init.js` ã¯æˆ‘ã€…ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®æœ€åˆã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ã€`admin.name` ã‚’ã‚»ãƒƒãƒˆã—ã¾ã™ã€‚ãã®å¾Œã€`admin.js` è‡ªèº«ã®å†…å´ã‹ã‚‰è¡Œã‚ã‚Œã‚‹å‘¼ã³å‡ºã—ã‚’å«ã‚ã€èª°ã‚‚ãŒãã‚Œã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚:
=======
Now, in `init.js`, the first script of our app, we set `admin.name`. Then everyone will see it, including calls made from inside `admin.js` itself:
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```js
// ğŸ“ init.js
import {admin} from './admin.js';
admin.name = "Pete";
```

```js
// ğŸ“ other.js
import {admin, sayHi} from './admin.js';

alert(admin.name); // *!*Pete*/!*

sayHi(); // Ready to serve, *!*Pete*/!*!
```

### import.meta

<<<<<<< HEAD
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ `import.meta` ã¯ç¾åœ¨ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«é–¢ã™ã‚‹æƒ…å ±ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚

ã“ã®å†…å®¹ã¯ç’°å¢ƒã«ä¾å­˜ã—ã¾ã™ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆã® urlã€HTML å†…ã§ã‚ã‚Œã°ç¾åœ¨ã®ã‚¦ã‚§ãƒ–ãƒšãƒ¼ã‚¸ã® url ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚:

```html run height=0
<script type="module">
  alert(import.meta.url); // script url (ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«å¯¾ã™ã‚‹ HTML ãƒšãƒ¼ã‚¸ã® url)
</script>
```

### æœ€ä¸Šä½ã® "this" ã¯ undefined

ã“ã‚Œã¯å°ã•ãªç‰¹å¾´ã§ã™ãŒã€å®Œå…¨æ€§ã®ãŸã‚ã«è¨€åŠã—ã¦ãŠãã¾ã™ã€‚

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯ã€æœ€ä¸Šä½ã® `this` ã¯éãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ãŠã‘ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯å¯¾ç…§çš„ã«ã€undefined ã§ã™ã€‚
=======
The object `import.meta` contains the information about the current module.

Its content depends on the environment. In the browser, it contains the url of the script, or a current webpage url if inside HTML:

```html run height=0
<script type="module">
  alert(import.meta.url); // script url (url of the html page for an inline script)
</script>
```

### Top-level "this" is undefined

That's kind of a minor feature, but for completeness we should mention it.

In a module, top-level `this` is undefined, as opposed to a global object in non-module scripts:
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```html run height=0
<script>
  alert(this); // window
</script>

<script type="module">
  alert(this); // undefined
</script>
```

<<<<<<< HEAD
## ãƒ–ãƒ©ã‚¦ã‚¶å›ºæœ‰ã®ç‰¹å¾´

é€šå¸¸ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨æ¯”ã¹ã¦ã€`type="module"` ã‚’æŒã¤ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶å›ºæœ‰ã®é•ã„ã‚‚ã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚

ã‚‚ã—åˆã‚ã¦èª­ã‚“ã§ã„ã‚‹å ´åˆã€ã¾ãŸã¯ãƒ–ãƒ©ã‚¦ã‚¶ã§ JavaScript ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚

### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯é…å»¶ã•ã‚Œã¾ã™

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯å¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆä¸¡æ–¹ã§ã€*å¸¸ã«* é…å»¶ã•ã‚Œã€`defer` å±æ€§(ãƒãƒ£ãƒ—ã‚¿ãƒ¼ [](info:onload-ondomcontentloaded) ã§èª¬æ˜ã—ã¦ã„ã¾ã™)ã¨åŒã˜åŠ¹æœã‚’æŒã¡ã¾ã™ã€‚

ã¤ã¾ã‚Š:
- å¤–éƒ¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆ `<script type="module" src="...">` ã¯ HTML å‡¦ç†ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚
- ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ HTML ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒå®Œå…¨ã«æº–å‚™ã§ãã‚‹ã¾ã§å¾…ã¡ã¾ã™ã€‚
- ç›¸å¯¾çš„ãªé †åºã¯ç¶­æŒã•ã‚Œã¾ã™: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æœ€åˆã«ã‚ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒæœ€åˆã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

å‰¯ä½œç”¨ã¨ã—ã¦ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯å¸¸ã«ãã®ä¸‹ã® HTML è¦ç´ ãŒè¦‹ãˆã¾ã™ã€‚

ä¾‹:
=======
## Browser-specific features

There are also several browser-specific differences of scripts with `type="module"` compared to regular ones.

You may want skip those for now if you're reading for the first time, or if you don't use JavaScript in a browser.

### Module scripts are deferred

Module scripts are *always* deferred, same effect as `defer` attribute (described in the chapter [](info:script-async-defer)), for both external and inline scripts.

In other words:
- external module scripts `<script type="module" src="...">` don't block HTML processing, they load in parallel with other resources.
- module scripts wait until the HTML document is fully ready (even if they are tiny and load faster than HTML), and then run.
- relative order of scripts is maintained: scripts that go first in the document, execute first.

As a side-effect, module scripts always "see" the fully loaded HTML-page, including HTML elements below them.

For instance:
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```html run
<script type="module">
*!*
<<<<<<< HEAD
  alert(typeof button); // object: ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ä¸‹ã®ãƒœã‚¿ãƒ³ãŒ `è¦‹ãˆ` ã¾ã™
*/!*
  // ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯é…å»¶ã•ã‚Œã‚‹ã®ã§ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ãƒšãƒ¼ã‚¸å…¨ä½“ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå¾Œã«å®Ÿè¡Œã—ã¾ã™
</script>

<script>
*!*
  alert(typeof button); // Error: button is undefined, ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ä¸‹ã®è¦ç´ ã¯è¦‹ãˆã¾ã›ã‚“
*/!*
  // é€šå¸¸ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ã€ãƒšãƒ¼ã‚¸ã®æ®‹ã‚ŠãŒå‡¦ç†ã•ã‚Œã‚‹å‰ã«å³æ™‚å®Ÿè¡Œã—ã¾ã™ã€‚
=======
  alert(typeof button); // object: the script can 'see' the button below
*/!*
  // as modules are deferred, the script runs after the whole page is loaded
</script>

Compare to regular script below:

<script>
*!*
  alert(typeof button); // Error: button is undefined, the script can't see elements below
*/!*
  // regular scripts run immediately, before the rest of the page is processed
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09
</script>

<button id="button">Button</button>
```

<<<<<<< HEAD
æ³¨æ„: å®Ÿéš›ã«ã¯1ã¤ç›®ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å‰ã«2ã¤ç›®ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒå‹•ä½œã—ã¾ã™! ãªã®ã§ã€æœ€åˆã« `undefined` ãŒè¡¨ç¤ºã•ã‚Œã€ãã®å¾Œ `object` ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

ã“ã‚Œã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒé…å»¶ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚é€šå¸¸ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ã™ãã«å®Ÿè¡Œã™ã‚‹ã®ã§ã€æœ€åˆã«å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†ã¨ãã¯ã€JavaScript ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæº–å‚™ã§ãã‚‹å‰ã« HTML ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒè¡¨ç¤ºã§ãã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ä¸€éƒ¨ã®æ©Ÿèƒ½ã¯ã¾ã æ©Ÿèƒ½ã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚é€æ˜ãªã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã€ã¾ãŸã¯ "ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°"ã‚’é…ç½®ã™ã‚‹ã€ã‚‚ã—ãã¯ãã‚Œä»¥å¤–ã®æ–¹æ³•ã§è¨ªå•è€…ãŒæ··ä¹±ã—ãªã„ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### Async ã¯ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§å‹•ä½œã—ã¾ã™

éåŒæœŸ(Async)å±æ€§ `<script async type="module">` ã¯ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã€å¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ä¸¡æ–¹ã§ä½¿ç”¨ã§ãã¾ã™ã€‚éåŒæœŸã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå‡¦ç†ã•ã‚Œã‚‹ã¨ã™ãã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ä»–ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚„ HTML ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ã¯ç‹¬ç«‹ã—ã¦ã„ã¾ã™ã€‚

ä¾‹ãˆã°ã€ä¸‹ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ `async` ãŒã‚ã‚‹ã®ã§ã€èª°ã‹ã‚’å¾…ã¤ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ãã‚Œã¯ã€ãŸã¨ãˆ HTMl ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒã¾ã å®Œäº†ã—ã¦ã„ãªã„å ´åˆã‚„ã€ä»–ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒã¾ã ä¿ç•™ã®å ´åˆã§ã‚‚ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆ `./analytics.js` ã®å–å¾—ï¼‰ã‚’è¡Œã„ã€æº–å‚™ãŒã§ããŸã¨ãã«å®Ÿè¡Œã—ã¾ã™ã€‚

ã“ã‚Œã¯ã‚«ã‚¦ãƒ³ã‚¿ã‚„åºƒå‘Šã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãªã©ã€ä½•ã«ã‚‚ä¾å­˜ã—ãªã„æ©Ÿèƒ½ã«é©ã—ã¦ã„ã¾ã™ã€‚

```html
<!-- ã™ã¹ã¦ã®ä¾å­˜å¯¾è±¡ãŒå–å¾—(analytics.js)ã•ã‚Œã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒå®Ÿè¡Œã•ã‚Œã¾ã™ -->
<!-- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚„ä»–ã® <script> ã‚¿ã‚°ã¯å¾…ã¡ã¾ã›ã‚“ -->
=======
Please note: the second script actually works before the first! So we'll see `undefined` first, and then `object`.

That's because modules are deferred, so way wait for the document to be processed. The regular scripts runs immediately, so we saw its output first.

When using modules, we should be aware that HTML-page shows up as it loads, and JavaScript modules run after that, so the user may see the page before the JavaScript application is ready. Some functionality may not work yet. We should put transparent overlays or "loading indicators", or otherwise ensure that the visitor won't be confused by that.

### Async works on inline scripts

Async attribute `<script async type="module">` is allowed on both inline and external scripts. Async scripts run immediately when imported modules are processed, independently of other scripts or the HTML document.

For example, the script below has `async`, so it doesn't wait for anyone.

It performs the import (fetches `./analytics.js`) and runs when ready, even if HTML document is not finished yet, or if other scripts are still pending.

That's good for functionality that doesn't depend on anything, like counters, ads, document-level event listeners.

```html
<!-- all dependencies are fetched (analytics.js), and the script runs -->
<!-- doesn't wait for the document or other <script> tags -->
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09
<script *!*async*/!* type="module">
  import {counter} from './analytics.js';

  counter.count();
</script>
```

<<<<<<< HEAD
### å¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

å¤–éƒ¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ã¯ã€2ã¤ã®å¤§ããªé•ã„ãŒã‚ã‚Šã¾ã™ã€‚:

1. åŒã˜ `src` ã®å¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ä¸€åº¦ã ã‘å®Ÿè¡Œã•ã‚Œã¾ã™:
    ```html
    <!-- ã‚¹ã‚¯ãƒªãƒ—ãƒˆ my.js ã¯ä¸€åº¦ã ã‘å–å¾—ã•ã‚Œå®Ÿè¡Œã•ã‚Œã¾ã™ -->
=======
### External scripts

There are two notable differences of external module scripts:

1. External scripts with same `src` run only once:
    ```html
    <!-- the script my.js is fetched and executed only once -->
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09
    <script type="module" src="my.js"></script>
    <script type="module" src="my.js"></script>
    ```

<<<<<<< HEAD
2. åˆ¥ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ã‹ã‚‰å–å¾—ã•ã‚ŒãŸå¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯[CORS](mdn:Web/HTTP/CORS) ãƒ˜ãƒƒãƒ€ã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚è¨€ã„æ›ãˆã‚‹ã¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒåˆ¥ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ã‹ã‚‰å–å¾—ã•ã‚ŒãŸå ´åˆã€ãƒªãƒ¢ãƒ¼ãƒˆã‚µãƒ¼ãƒã¯ãã®å–å¾—ãŒè¨±å¯ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«ã€ãƒ˜ãƒƒãƒ€  `Access-Control-Allow-Origin: *` (`*` ã®ä»£ã‚ã‚Šã«å–å¾—ã™ã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’æŒ‡å®šã™ã‚‹å ´åˆã‚‚ã‚ã‚Šã¾ã™)ã‚’æä¾›ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
    ```html
    <!-- another-site.com ã¯ Access-Control-Allow-Origin ã‚’æä¾›ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ -->
    <!-- ãã†ã§ãªã„å ´åˆã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ -->
    <script type="module" src="*!*http://another-site.com/their.js*/!*"></script>
    ```

    ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãŒå‘ä¸Šã—ã¾ã™ã€‚

### ãƒ™ã‚¢(å‰¥ãå‡ºã—ã®) ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“

ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ä¸­(HTML ã§ã¯ãªã„)ã§ã€`import` ã¯ç›¸å¯¾URLã‹çµ¶å¯¾URLã€ã©ã¡ã‚‰ã‹ã®å–å¾—ãŒå¿…é ˆã§ã™ã€‚
ãƒ‘ã‚¹ã®ãªã„ã€ã„ã‚ã‚†ã‚‹ "å‰¥ãå‡ºã—ã®" ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚

ä¾‹ãˆã°ã€ã“ã® `import` ã¯ç„¡åŠ¹ã§ã™:

```js
import {sayHi} from 'sayHi'; // Error, "bare" module
// './sayHi.js' ã¾ãŸã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´æ‰€ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“
```

Node.js ã‚„ãƒãƒ³ãƒ‰ãƒ«ãƒ„ãƒ¼ãƒ«ã®ã‚ˆã†ãªç‰¹å®šã®ç’°å¢ƒã§ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã®ç‹¬è‡ªã®æ–¹æ³•ã‚„ã€ãã‚Œã‚‰ã‚’èª¿æ•´ã™ã‚‹ãŸã‚ã®ãƒ•ãƒƒã‚¯ãŒã‚ã‚‹ãŸã‚ã€å‰¥ãå‡ºã—ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã¾ã ãƒ™ã‚¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚

### äº’æ›æ€§, "nomodule"

å¤ã„ãƒ–ãƒ©ã‚¦ã‚¶ã¯ `type="module"` ã‚’ç†è§£ã—ã¾ã›ã‚“ã€‚æœªçŸ¥ã®ã‚¿ã‚¤ãƒ—ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯å˜ã«ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ãã‚Œã‚‰ã«ã¯ã€`nomodule` å±æ€§ã‚’ä½¿ã£ã¦ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’æä¾›ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚:
=======
2. External scripts that are fetched from another domain require [CORS](mdn:Web/HTTP/CORS) headers. In other words, if a module script is fetched from another domain, the remote server must supply a header `Access-Control-Allow-Origin: *` (may use fetching domain instead of `*`) to indicate that the fetch is allowed.
    ```html
    <!-- another-site.com must supply Access-Control-Allow-Origin -->
    <!-- otherwise, the script won't execute -->
    <script type="module" src="*!*http://another-site.com/their.js*/!*"></script>
    ```

    That ensures better security by default.

### No "bare" modules allowed

In the browser, `import` must get either a relative or absolute URL. Modules without any path are called "bare" modules. Such modules are not allowed in `import`.

For instance, this `import` is invalid:
```js
import {sayHi} from 'sayHi'; // Error, "bare" module
// the module must have a path, e.g. './sayHi.js' or wherever the module is
```

Certain environments, like Node.js or bundle tools allow bare modules, without any path, as they have own ways for finding modules and hooks to fine-tune them. But browsers do not support bare modules yet.

### Compatibility, "nomodule"

Old browsers do not understand `type="module"`. Scripts of the unknown type are just ignored. For them, it's possible to provide a fallback using `nomodule` attribute:
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09

```html run
<script type="module">
  alert("Runs in modern browsers");
</script>

<script nomodule>
<<<<<<< HEAD
  alert("ç¾åœ¨ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ type=module ã¨ nomodule ã©ã¡ã‚‰ã‚‚çŸ¥ã£ã¦ã„ã‚‹ã®ã§ã€ã“ã‚Œã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã™")
  alert("å¤ã„ãƒ–ãƒ©ã‚¦ã‚¶ã¯æœªçŸ¥ã® type=module ã‚’æŒã¤ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ç„¡è¦–ã—ã¾ã™ãŒã€ã“ã‚Œã¯å®Ÿè¡Œã—ã¾ã™");
</script>
```

ãƒãƒ³ãƒ‰ãƒ«ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚ä¸€ç·’ã«ãƒãƒ³ãƒ‰ãƒ«ã•ã‚Œã‚‹ã¨ã€ãã‚Œã‚‰ã® `import/export` æ–‡ã¯ç‰¹åˆ¥ãªãƒãƒ³ãƒ‰ãƒ«å‘¼ã³å‡ºã—ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ãƒ“ãƒ«ãƒ‰ã¯ `type=module` ã‚’å¿…è¦ã¨ã—ã¾ã›ã‚“ã€‚ãªã®ã§ã€ãã‚Œã‚’é€šå¸¸ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ç½®ãã“ã¨ãŒã§ãã¾ã™ã€‚:

```html
<!-- Webpack ã®ã‚ˆã†ãªãƒ„ãƒ¼ãƒ«ã‹ã‚‰ bundle.js ã‚’å¾—ãŸæƒ³å®š -->
<script src="bundle.js"></script>
```

## ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«

ç¾å®Ÿã«ã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ "ç”Ÿ" ã®å½¢å¼ã§ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ã¯ã»ã¨ã‚“ã©ã‚ã‚Šã¾ã›ã‚“ã€‚é€šå¸¸ã€ãã‚Œã‚‰ã‚’ [Webpack](https://webpack.js.org/) ãªã©ã®ç‰¹åˆ¥ãªãƒ„ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ä¸€ç·’ã«ã¾ã¨ã‚ã¦ã€ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã‚µãƒ¼ãƒã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã™ã€‚

ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹åˆ©ç‚¹ã®1ã¤ã¯ã€ãã‚Œã‚‰ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã©ã®ã‚ˆã†ã«è§£æ±ºã™ã‚‹ã‹ã«ã¤ã„ã¦ã‚ˆã‚Šå¤šãã®åˆ¶å¾¡ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã€CSS/HTML ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚ˆã†ã«ãƒ™ã‚¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ãã®ä»–ã®ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚

ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«ã¯æ¬¡ã®ã“ã¨ã‚’è¡Œã„ã¾ã™ã€‚:

1. HTML ã® `<script type="module">` ç½®ãã“ã¨ã‚’æ„å›³ã—ãŸ "ãƒ¡ã‚¤ãƒ³" ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å–ã‚Šã¾ã™ã€‚
2. ä¾å­˜é–¢ä¿‚ã‚’åˆ†æã—ã¾ã™: ã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ...ãªã©
3. ãƒã‚¤ãƒ†ã‚£ãƒ–ã® `import` å‘¼ã³å‡ºã—ã‚’ãƒãƒ³ãƒ‰ãƒ©é–¢æ•°ã§ç½®ãæ›ãˆã€ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’1ã¤ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ“ãƒ«ãƒ‰ã—ã¾ã™(ã‚‚ã—ãã¯è¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã—ã¾ã™ã€‚èª¿æ•´å¯èƒ½)ã€‚
4. ãã®éç¨‹ã§ã€ä»–ã®å¤‰æ›ã‚„æœ€é©åŒ–ã‚’é©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
    - åˆ°é”ä¸èƒ½ã®ã‚³ãƒ¼ãƒ‰ã®å‰Šé™¤
    - æœªä½¿ç”¨ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã®å‰Šé™¤("tree-shaking")
    - `console` ã‚„ `debugger` ã®ã‚ˆã†ãªé–‹ç™ºå›ºæœ‰ã®æ–‡ã®å‰Šé™¤
    - æœ€å…ˆç«¯ã® JavaScript æ§‹æ–‡ã¯ã€[Babel](https://babeljs.io/)] ã‚’ä½¿ç”¨ã—ã¦åŒæ§˜ã®æ©Ÿèƒ½ã‚’æŒã¤å¤ã„æ§‹æ–‡ã«å¤‰æ›ã•ã‚Œã¾ã™
    - çµæœã®ãƒ•ã‚¡ã‚¤ãƒ«ã® minify (ã‚¹ãƒšãƒ¼ã‚¹ã®å‰Šé™¤ã€å¤‰æ•°ã‚’çŸ­ã„åå‰ã«ç½®æ›ã™ã‚‹ãªã©)

ã¨ã¯ã„ãˆã€ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚ä½¿ç”¨å¯èƒ½ã§ã™ã€‚ãªã®ã§ã€ã“ã“ã§ã¯ Webpack ã¯ä½¿ç”¨ã—ã¾ã›ã‚“ã€‚ã‚‚ã¡ã‚ã‚“å¾Œã§è¨­å®šã™ã‚‹ã“ã¨ã¯å¯èƒ½ã§ã™ã€‚

## ã‚µãƒãƒª

ã¾ã¨ã‚ã‚‹ã¨ã€ã‚³ã‚¢ã®æ¦‚å¿µã¯æ¬¡ã®é€šã‚Šã§ã™:

1. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚`import/export` ã‚’æ©Ÿèƒ½ã•ã›ã‚‹ã«ã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ã¯ `<script type="module">` ã‚’å¿…è¦ã¨ã—ã€ãã‚Œã¯ã„ãã¤ã‹ã®é•ã„ã‚’æ„å‘³ã—ã¾ã™ã€‚:
    - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯é…å»¶
    - éåŒæœŸã¯ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§å‹•ä½œã™ã‚‹
    - å¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ CORS ãƒ˜ãƒƒãƒ€ã‚’å¿…è¦ã¨ã™ã‚‹
    - é‡è¤‡ã—ãŸå¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ç„¡è¦–ã•ã‚Œã‚‹
2. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ç‹¬è‡ªã®ãƒ­ãƒ¼ã‚«ãƒ«ã®æœ€ä¸Šä½ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŒã¡ã€`import/export` çµŒç”±ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã§æ©Ÿèƒ½ã‚’ã‚„ã‚Šå–ã‚Šã—ã¾ã™ã€‚
3. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å¸¸ã« `use strict` ã§ã™ã€‚
4. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒ¼ãƒ‰ã¯ä¸€åº¦ã ã‘å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã¯ä¸€åº¦ç”Ÿæˆã•ã‚Œã€ã‚¤ãƒ³ãƒãƒ¼ã‚¿é–“ã§å…±æœ‰ã•ã‚Œã¾ã™ã€‚

ã—ãŸãŒã£ã¦ã€é€šå¸¸ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã€å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã€ãã‚Œã‚‰ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ãã—ã¦ã€`import` ã‚’ä½¿ã£ã¦ã€å¿…è¦ãªå ´æ‰€ã«ç›´æ¥ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã¯è‡ªå‹•çš„ã«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’èª­ã¿è¾¼ã¿ã€è©•ä¾¡ã—ã¾ã™ã€‚

ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç’°å¢ƒã§ã¯å¤šãã®å ´åˆã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚„ä»–ã®ç†ç”±ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’1ã¤ã«ã¾ã¨ã‚ã‚‹ãŸã‚ã« [Webpack](https://webpack.js.org) ãªã©ã®ãƒãƒ³ãƒ‰ãƒ©ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

æ¬¡ã®ãƒãƒ£ãƒ—ã‚¿ãƒ¼ã§ã¯ã€ã‚ˆã‚Šå¤šãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¾‹ã¨ã€ã©ã®ã‚ˆã†ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ã‹ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚
=======
  alert("Modern browsers know both type=module and nomodule, so skip this")
  alert("Old browsers ignore script with unknown type=module, but execute this.");
</script>
```

If we use bundle tools, then as scripts are bundled together into a single file (or few files), `import/export` statements inside those scripts are replaced by special bundler functions. So the resulting "bundled" script does not contain any `import/export`, it doesn't require `type="module"`, and we can put it into a regular script:

```html
<!-- Assuming we got bundle.js from a tool like Webpack -->
<script src="bundle.js"></script>
```

## Build tools

In real-life, browser modules are rarely used in their "raw" form. Usually, we bundle them together with a special tool such as [Webpack](https://webpack.js.org/) and deploy to the production server.

One of the benefits of using bundlers -- they give more control over how modules are resolved, allowing bare modules and much more, like CSS/HTML modules.

Build tools do the following:

1. Take a "main" module, the one intended to be put in `<script type="module">` in HTML.
2. Analyze its dependencies: imports and then imports of imports etc.
3. Build a single file with all modules (or multiple files, that's tunable), replacing native `import` calls with bundler functions, so that it works. "Special" module types like HTML/CSS modules are also supported.
4. In the process, other transforms and optimizations may be applied:
    - Unreachable code removed.
    - Unused exports removed ("tree-shaking").
    - Development-specific statements like `console` and `debugger` removed.
    - Modern, bleeding-edge JavaScript syntax may be transformed to older one with similar functionality using [Babel](https://babeljs.io/).
    - The resulting file is minified (spaces removed, variables replaced with shorter named etc).

That said, native modules are also usable. So we won't be using Webpack here: you can configure it later.

## Summary

To summarize, the core concepts are:

1. A module is a file. To make `import/export` work, browsers need `<script type="module">`, that implies several differences:
    - Deferred by default.
    - Async works on inline scripts.
    - To load external scripts from another origin (domain/protocol/port), CORS headers are needed.
    - Duplicate external scripts are ignored.
2. Modules have their own, local top-level scope and interchange functionality via `import/export`.
3. Modules always `use strict`.
4. Module code is executed only once. Exports are created once and shared between importers.

So, generally, when we use modules, each module implements the functionality and exports it. Then we use `import` to directly import it where it's needed. Browser loads and evaluates the scripts automatically.

In production, people often use bundlers such as [Webpack](https://webpack.js.org) to bundle modules together for performance and other reasons.

In the next chapter we'll see more examples of modules, and how things can be exported/imported.
>>>>>>> 9b5c1c95ec8a466150e519b0e94748717c747b09
