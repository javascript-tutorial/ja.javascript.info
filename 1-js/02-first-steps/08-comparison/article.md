# 比較

私たちが数学で知っている多くの比較演算子があります。:

- より大きい/より小さい: <code>a &gt; b</code>, <code>a &lt; b</code>
- 大きい/小さいまたは等しい: <code>a &gt;= b</code>, <code>a &lt;= b</code>.
- 等位チェックは `a == b` として書かれます(2重の等式記号 `'='` に注意してください。1つのシンボル `a = b` は代入を意味します。)
- 等しくない。数学において、この記法は <code>&ne;</code> です。JavaScriptにおいては、感嘆符がその前についた代入として書かれます: <code>a != b</code>.

[cut]

## 結果はBoolean 

他のすべての演算子と同様、比較も値を返却します。値はBoolean型です。

- `true` -- "はい", "正しい" もしくは "真" を意味します.
- `false` --　"いいえ", "誤り" もしくは "偽" を意味します.

例:

```js run
alert( 2 > 1 );  // true (正しい)
alert( 2 == 1 ); // false (誤り)
alert( 2 != 1 ); // true (正しい)
```

任意の値のように、比較結果は変数に代入することができます:

```js run
let result = 5 > 4; // 比較の結果を代入
alert( result ); // true
```

## 文字列比較 

どちらの文字列がより大きいかを見る場合、いわゆる "辞書" もしくは "数学における辞書式順序" の順序が使われます。

言い換えると、文字列は文字単位で比較されます。

例:

```js run
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

2つの文字列を比較するアルゴリズムはシンプルです:

1. 両方の文字列の最初の文字を比較します。
2. もしも1つ目のほうが大きい(もしくは小さい)場合、1つ目の文字列は2つ目の文字列よりも大きい(もしくは小さい)です。それで完了です。
3. そうではなく、もしも最初の文字が等しい場合は、同じ方法で2つ目の文字を比較します。
4. 文字列の最後までそれを繰り返します。
5. もしも両方の文字列が同時に終わった場合、それらは等しいです。そうでなければ長い文字列がより大きいです。

上の例において、比較 `'Z' > 'A'` は最初のステップで結果を得ます。

文字列 `"Glow"` と `"Glee"` は文字単位の比較がされます。

1. `G` は `G` と同じ.
2. `l` は `l` と同じ.
3. `o` は `e` より大きい. ここでストップ. 1つ目の文字列のほうが大きいです.

```smart header="実際の辞書ではなく、Unicode順です"
上で与えられている比較アルゴリズムは、本の辞書や電話帳で使われているのとおおよそ同じです。しかし全く同じではありません。

例えば、大文字小文字の問題。大文字 `"A"` は小文字の `"a"` とは同じではありません。どちらがより大きいでしょう？実際は、小文字 `"a"` です。なぜでしょう？なぜなら、小文字は内部のエンコーディングテーブル(Unicode)でより大きな索引を持っているからです。チャプター <info:string> で具体的な詳細と結果を取り上げます。
```

## 異なる型の比較 

異なった型に所属している値を比較するとき、それらは数値に変換されます。

例:

```js run
alert( '2' > 1 ); // true, 文字列 '2' は数値 2 になります
alert( '01' == 1 ); // true, 文字列 '01' は数値 1 になります
```

真偽値の場合、`true` は `1` になり、 `false` は `0` になります。:

```js run
alert( true == 1 ); // true
alert( false == 0 ); // true
```

````smart header="興味深い結果"
次の2つが同時に発生する場合があります:

- 2つの値が等しい
- それらの一方は真偽値の `true` で、もう一方は真偽値の `false`

例:

```js run
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

JavaScriptの立場からすると、それは普通です。等価チェックは数値変換を使って変換をします(したがって、`"0"` は `0` になります)。
一方、 `真偽値` 変換は別のルールセットを利用します。
````

## 厳密な等価 

通常の等価チェック `"=="` は問題を持っています。`0` と `false` を異なるものと判断させることはできません:

```js run
alert( 0 == false ); // true
```

空文字列でも同じです:

```js run
alert( '' == false ); // true
```

それは、異なる型のオペランドは等価演算子 `==` によって数値に変換されるためです。空文字は、ちょうど `false` のようにゼロになります。

もしも `0` と `false` を分けたい場合、どうすべきでしょうか？

**厳密等価演算子 `===` は型変換なしで等価をチェックします。**

言い換えると、もしも `a` と `b` が異なる型の場合、`a === b` はそれらの変換の試みをすることなく、すぐに `false` を返します。

試してみましょう:

```js run
alert( 0 === false ); // false, 型が異なるためです
```

`!=` の類似として、"厳密な非等価" 演算子 `!==` もまた存在します。

厳密等価チェック演算子は書くのが少し長いですが、起こっていることを明らかにし、エラーの余地を少なくします。

## null と undefined の比較 

より多くのエッジケースを見てみましょう。

`null` もしくは `undefined` が他の値と比較される場合、非直感的な振る舞いになります。

厳密な等価チェック `===` の場合
: それぞれ、それ自身の別々の型に所属しているため、これらの値は異なります。

```js run
alert( null === undefined ); // false
```

非厳密なチェック `==` の場合
: 特別なルールがあります。それら2つは "甘いカップル" です: それらはお互いに等しくなります(`==` の意味で)が、価値はありません。

```js run
alert( null == undefined ); // true
```

数学や他の比較 `< > <= >=`
: 値 `null/undefined` は数値に変換されます: `null` は `0` になり、`undefined` は `NaN` になります。

今、それらのルールを適用した時に起こる面白いことを見てみましょう。そして、より重要なことはこれらの機能でトラップに陥らない方法です。

### 奇妙な結果: null vs 0

`null` とゼロを比較してみましょう:

```js run
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) *!*true*/!*
```

はい、数学的にはそれらは奇妙です。最後の結果は "`null` はゼロより大きいまたは等しい" ことを述べています。そして上の比較の1つは正しいはずですが、それらは両方とも false です。

その理由は等価チェック `==` と比較 `> < >= <=` は異なった処理するためです。比較 `null` を数値に変換します、したがって `0` として扱います。そういう訳で (3) `null >= 0` は true で、 (1) は false になります。

一方、`undefined` と `null` の等価チェック `==` はいずれの変換もなしにルールによって処理します。それらはお互い等価で他のいずれとも等価ではありません。そういうわけで (2) `null == 0` は false です。

### 比べるもののない undefined

値 `undefined` は比較において参加するべきではありません。:

```js run
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

なぜそこまでゼロが嫌いなのでしょう？常に false です!

このような結果になった理由は次の通りです:

- 比較 `(1)` と `(2)` は、 `undefined` は `NaN` に変換されるため `false` を返します。また、`NaN` はすべての比較で `false` を返す特別な数値です。
- `undefined` は `null` とのみ等価で、それ以外とは等価ではないため、等価チェック `(3)` は `false` を返します。

### 問題を回避する

なぜそれらのサンプルを観察したのでしょう？我々は常にこれらの特殊性を覚えておく必要がありますか？まぁ、実際にはありません。
実際には、それらのトリッキーなことは、時間とともに馴染みの深いものになっていくでしょう。しかし問題を回避するための確実な方法があります。

例外的な注意を払って、厳密な等価 `===` を除き `undefined/null` の比較を行うだけです。

あなたがしていることが本当に正しい場合でない限り、`null/undefined` かもしれない変数に対して比較 `>= > < <=` は使ってはいけません。
もしも変数がこのような値を持つ可能性がある場合は、それらを別々にチェックしてください。

## サマリ 

- 比較演算子は論理値を返します。
- 文字列は "辞書” 順で、1文字ずつ比較されます。
- 異なった型の値が比較される場合、それらは数値に変換されます(厳密な等価チェックを除く)
- 値 `null` と `undefined` はそれぞれ等価 `==` であり、それ以外の値とは等価ではありません。
- `>` または `<` のような比較を、時には `null/undefined` になるような変数に対して使う場合は注意してください。`null/undefined` を別々にチェックすることは良いアイデアです。
