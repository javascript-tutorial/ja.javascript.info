# 関数式とアロー

JavaScriptでは、関数は "魔法の言語構造" ではなく、特別な種類の値です。

[cut]

以前私たちが使っているた構文は *関数宣言* と呼ばれます:

```js
function sayHi() {
  alert( "Hello" );
}
```

*関数式* と呼ばれる、関数を作るための別の項分があります。

それはこのようになります:

```js
let sayHi = function() {
  alert( "Hello" );
};
```

ここで、他の任意の値と同じように、関数は作られ明示的に変数に代入されています。
どのように変数が定義されても、それは単に変数 `sayHi` に格納される値です。

これらのコード例の意味は同じです: "関数を作成し、変数 `sayHi` にそれを置きます"

`alert` を使ってその値を出力することもできます:

```js run
function sayHi() {
  alert( "Hello" );
}

*!*
alert( sayHi ); // 関数のコードが表示されます
*/!*
```

`sayHi` の後に括弧がないので、最後の行は関数が実行されないことに注意してください。関数名への言及がその実行を引き起こすプログラミング言語も存在しますが、JavaScriptはそうではありません。

JavaScriptでは、関数は値です。そのため、それを値として扱うことができます。上のコードはその文字列表現を表示し、それはソースコードです。

`sayHi()` のように呼ぶことができる点で、もちろんそれは特別な値です。

しかし、それはまだ値なので他の種類の値のようにそれを扱うことができます。

関数を別の変数にコピーすることが出来ます:

```js run no-beautify
function sayHi() {   // (1) 作成
  alert( "Hello" );
}

let func = sayHi;    // (2) コピー

func(); // Hello     // (3) コピーの実行(動きます)!
sayHi(); // Hello    //     これもまだ動きます(なぜでしょう？)
```

上記で起こっていることの詳細は次の通りです:

1. 関数宣言 `(1)` で関数を生成し、変数名 `sayHi` に置きます。
2. 行 `(2)` でそれを変数 `func` にコピーします。

    改めて注意してください:`sayHi` の後に括弧はありません。もしそれがあった場合、`sayHi` の *関数自身* ではなく、`func = sayHi()` は `sayHi()` の呼び出しの結果を `func` に書き込みます。
3. 今や、関数は `sayHi()` と `func()` 両方で呼ぶことができます。

私たちは、1行目で、`sayHi` を宣言するために関数式を使うこともできます:

```js
let sayHi = function() { ... };

let func = sayHi;
// ...
```

すべて同じように動作します。さらに何が起こっているのか、より明白ですね。


````smart header="なぜ末尾にセミコロンがあるのでしょう？"
疑問があるかもしれません。なぜ関数式は末尾にセミコロン `;` を持つのか、そして関数宣言にはそれがないのか:

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

答えはシンプルです:
- コードブロックや `if { ... }`, `for {  }`, `function f { }` などの構文構造の末尾に `;` が必要ありません。
- 関数式は文の内側で使われます: `let sayHi = ...;` を値として利用します。それはコードブロックではありません。セミコロン `;` はどんな値であれ文の最後に推奨されています。そのため、ここのセミコロンは関数式自体になんら関係しません、単に文の終わりです。
````

## コールバック関数 [#callback-functions]

値として関数を渡し、関数式を使う例をみてみましょう。

私たちは、3つのパラメータを持つ関数 `ask(question, yes, no)` を書きます:

`question`
: 質問のテキスト

`yes`
: もしも答えが "はい" の場合に実行する関数

`no`
: もしも答えが "いいえ" の場合に実行する関数

関数は `question` を訪ね、ユーザの回答に合わせて、`yes()` または `no()` を呼びます:

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// 使用法: 関数 showOk, showCancel は ask の引数として渡されます
ask("Do you agree?", showOk, showCancel);
```

これに関して、より短く記述する方法を探す前に、ブラウザ(といくつかのサーバサイドのケース)では、このような関数はかなり普及していることに留意しましょう。実際の実装と上の例の主な違いは、実際の関数は単純な `confirm` よりも、ユーザとやり取りするためにより複雑な方法を利用することです。ブラウザでは、このような関数は、通常良く見える質問ウィンドウに描画されます。しかしそれは別の話です。

**`ask`の引数は *コールバック関数* または単に *コールバック* と呼ばれます。**

この考え方は、私たちは関数を渡し、それがもし必要であれば後で "呼び戻す" ことを期待します。このケースでは、`showOK` は "はい" のためのコールバックになり、`showCancel` は "いいえ" の回答のためです。

同じ関数をより短く書くために関数式を使うことが出来ます:

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*!*
ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
*/!*
```

ここでは、関数は `ask(...)` 呼び出しの中で正しく宣言されています。それらは名前を持たないので、*無名* と呼ばれます。
このような関数は `ask` の外側からアクセスできません(変数に割り当てられていないため)、しかしそれはここで欲しいものです。

このようなコードは我々のスクリプトでとても自然に表れます。それは JavaScript の精神に基づいています。

```smart header="関数は \"アクション\" を表す値です"
文字列や数値のような通常の値は *データ* を表します。

関数は *アクション* として認識されます。

私たちは、変数間でそれを渡し、必要な時に実行させることができます。
```


## 関数式 vs 関数宣言 [#function-expression-vs-function-declaration]

関数宣言と関数式の違いを明確に述べてみましょう。

まず、構文です:

- *関数宣言:* メインのコードフローで別の文として宣言された関数

    ```js
    // 関数宣言
    function sum(a, b) {
      return a + b;
    }
    ```
- *関数式:* 式の内部、または別の構文構造の中で作れらた関数

    ここで、関数は "代入式 =" の右側に作成されます。:
    ```js
    // 関数式
    let sum = function(a, b) {
      return a + b;
    };
    ```

よりささいな違いは、関数がJavaScriptエンジンによって *作られたとき* です。

**関数式は、実行がそれに到達した時に作られ、それ以降、利用可能になります。**

一度実行フローが代入 `let sum = function…` の右辺へ渡ったら -- 関数は作られ、そこから使えるようになります(代入や呼び出しなど)。

関数宣言は異なります

**関数宣言はスクリプト/コードブロック全体で使用できます。**

言い換えると、JavaScriptがスクリプトまたはコードブロックの実行の準備をする時、最初にその中の関数定義を探し、関数を生成します。私たちはそれを "初期化段階" として考えることが出来ます。

そして、全ての関数宣言が処理されたあと、実行が続けられます。

結果的に、関数宣言として宣言された関数は、定義された関数よりも早く呼ぶことができます。

例えば、これは動作します:

```js run refresh untrusted
*!*
sayHi("John"); // Hello, John
*/!*

function sayHi(name) {
  alert( `Hello, ${name}` );
}
```

関数宣言 `sayHi` は、JavaScriptがスクリプトの開始の準備をしているときに生成され、その中でどこからでも見えます。

...もしもそれが関数式だった場合、動作しないでしょう:

```js run refresh untrusted
*!*
sayHi("John"); // エラー!
*/!*

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
```

関数式は、実行がそれに到達した時に作られます。それは行 `(*)` でのみ起こります。遅すぎます。

**関数宣言がコードブロックの中で作られるとき、そのブロックの内側であればどこからでも見えます。しかし、その外側からは見えません。**

必要とされるブロックの中だけでローカル変数を宣言することは、時には便利です。しかし、その機能も問題を引き起こす可能性があります。

例えば、私たちがランタイムの中で得た `age` 変数に依存する関数 `welcome()` を宣言する必要があるとしましょう。そして、しばらくしてから使用することを予定します。

下のコードはうまく動作しません:

```js run
let age = prompt("What is your age?", 18);

// 条件付きで関数を宣言する
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...後でそれを使う
*!*
welcome(); // エラー: welcome は未定義です
*/!*
```

なぜなら、関数宣言は、それが存在するコードブロックの内側でのみ見えるからです。

別の例です:

```js run
let age = 16; // 例として16

if (age < 18) {
*!*
  welcome();               // \   (実行)
*/!*
                           //  |
  function welcome() {     //  |  
    alert("Hello!");       //  |  関数宣言はそれが宣言されたブロックの中であれば
  }                        //  |  どこでも利用可能です
                           //  |
*!*
  welcome();               // /   (実行)
*/!*

} else {

  function welcome() {     //  age = 16 の場合, この "welcome" は決して作られません
    alert("Greetings!");
  }
}

// ここは、波括弧の外です
// なのでその中で作られた関数宣言は見ることができません

*!*
welcome(); // エラー: welcome は定義されていません
*/!*
```

`if` の外側で `welcome` を見えるようにするためにはどうしたらよいでしょうか？

正しいアプローチは、関数式を使い、`welcome` を `if` の外で宣言され、適切なスコープをもつ変数に代入することです。

これは、意図したとおりに動作します:

```js run
let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

*!*
welcome(); // ok now
*/!*
```

もしくは、疑問符演算子 `?` を使うことでさらにシンプルにできます:

```js run
let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

*!*
welcome(); // ok now
*/!*
```


```smart header="関数宣言と関数式のどちらを選択するのか？"
経験則として、私たちが関数を宣言する必要があるとき、最初に考えるのは、以前私たちが使った関数宣言構文です。私たちはこれらの関数が宣言される前に呼ぶことができるため、コードを体系化する自由度が増します。

また、コードの中で、`let f = function(…) {…}` よりも `function f(…) {…}`  の方が調べるのが少し簡単です。関数宣言はより "目を引きます"。

...しかし、関数宣言が幾つかの理由で適していない場合(上でみた例)、関数式が使われるべきです。
```


## アロー関数 [#arrow-functions]

関数を作成ための、より非常にシンプルで簡潔な構文がもう1つあります。それはしばしば関数式よりも優れています。これは "アロー関数" と呼ばれ、次のようになります:

```js
let func = (arg1, arg2, ...argN) => expression
```

...これは引数 `arg1..argN` をもち、右側でそれらを使用する `expression` を評価し、その結果を返す関数 `func` を作ります。

言い換えると、次のコードと概ね一緒です:

```js
let func = function(arg1, arg2, ...argN) {
  return expression;
}
```

...が、はるかに簡潔です

例を見てみましょう:

```js run
let sum = (a, b) => a + b;

/* アロー関数は次の形式のより短い形です:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3

```

もしも引数が1つだけの場合、括弧は省略可能なので、さらに短くできます:

```js run
// 次と同じです
// let double = function(n) { return n * 2 }
*!*
let double = n => n * 2;
*/!*

alert( double(3) ); // 6
```

もしも引数がない場合、括弧は必須で、空白にします:

```js run
let sayHi = () => alert("Hello!");

sayHi();
```

アロー関数は、関数式として同じ方法で使用できます。

例えば、ここでは `welcome()` の例を再び書きます:

```js run
let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('Hello') :
  () => alert("Greetings!");

welcome(); // ok now
```

アロー関数は、最初は馴染みが無く、読みにくいように見えるかもしれませんが、構造に慣れるとすぐに変わります。

多くの文字を書くのが面倒なとき、シンプルなワンライナーの処理を書くときにはとても便利です。

```smart header="複数行のアロー関数"

上の例は、`=>` の左から引数を取得し、右側の式を評価しました。

複数の式や文のようにもう少し複雑なものが必要な時があります。それもまた可能ですが、この場合は括弧で囲む必要があります。そして、その中で通常の `return` を使います。

このようになります:

```js run
let sum = (a, b) => {  // 波括弧を使って複数行の関数を書けます
  let result = a + b;
*!*
  return result; // 波括弧を使った場合、結果を得るには return を使います
*/!*
};

alert( sum(1, 2) ); // 3
```

```smart header="他にもあります"
ここでは、簡潔にするためにアロー関数を賞賛しました。しかし、それだけではありません!!アロー関数は他にも興味深い機能を持っています。後ほどチャプター<info:arrow-functions> で触れます。

現時点では、既にワンライナーの処理やコールバックのためにそれらを使うことが出来ます。
```

## サマリ [#summary]

- 関数は値です。それらは、コード上のどの場所でも、割り当てたり、コピーしたり、宣言することができます。
- もしも、関数がメインのコードフローの中で別の文として宣言されていたら、それは "関数宣言" と呼ばれます。
- もしも関数が式の一部として作られたら、それは "関数式" と呼ばれます。
- 関数宣言は、コードブロックが実行される前に処理されます。それらはブロックの中ではどこからでも見えます。
- 関数式は、実行フローがそれに到達した時に作られます。

ほとんどのケースでは、関数の宣言が必要な場合、関数宣言が望ましいです。なぜなら、それ自身の宣言の前で見えるためです。これにより、コード構成の柔軟性が増し、通常は読みやすくなります。

従って、関数宣言がそのタスクに適さない場合にのみ関数式を使うべきです。このチャプターで幾つかの例を見て来ました、そして今後もっと見ていくでしょう。

アロー関数はワンライナーのために便利です。それらは2つの旨味があります:

1. 括弧無し: `(...args) => expression` -- 右側は式です: 関数はそれを評価しその結果を返します。
2. 括弧あり: `(...args) => { body }` -- 括弧があると、関数内で複数の文を書くことができます、しかし何かを返却する場合には、明確に `return` が必要です。
