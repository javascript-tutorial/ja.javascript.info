# ループ: while と for

私たちはしばしば連続して何度も似たような処理を実行する必要があります。

例えば、1つずつリストから商品を出力する必要がある場合、または単に1から10の数値それぞれに同じコードを実行する場合などです。

*ループ* は複数回コードの同じ部分を繰り返す方法です。

[cut]

## "while" ループ 

`while` ループは次の構文を持っています:

```js
while (condition) {
  // code
  // いわゆる "ループ本体"
}
```

`condition` が `true` の間、ループの本体の `code` が実行されます。

例えば、下のループは `i < 3` の間、`i` を出力します:

```js run
let i = 0;
while (i < 3) { // 0, 次に 1, 次に 2 を表示
  alert( i );
  i++;
}
```

ループ本体の1回の実行は *イテレーション* と呼ばれます。上の例のループは3回イテレーションします。

もしも、上の例に `i++` がない場合、ループは (理論上は) 永遠に繰り返されます。実際には、ブラウザはこのようなループを止める方法を提供しており、サーバサイドJavaScriptではそのプロセスを殺すことができます。

任意の式または変数は、単に比較ではなくループ条件になります。それらは評価され `while` によって真偽値に変換されます。

たとえば、`while (i != 0)` をより短く書く方法として`while (i)`があります:

```js run
let i = 3;
*!*
while (i) { // i が 0 になったとき、条件が偽になり、ループが止まります
*/!*
  alert( i );
  i--;
}
```

````smart header="本体が1行の場合、括弧は必須ではありません"
ループの本体が1つの文である場合、括弧`{…}`を省略することができます:

```js run
let i = 3;
*!*
while (i) alert(i--);
*/!*
```
````

## "do..while" ループ 

条件チェックは `do..while` 構文を使うことでループ本体の *下に* 移動させることができます。:

```js
do {
  // loop body
} while (condition);
```

ループは最初に本体を実行します、次に条件をチェックし、真となる間実行を繰り返します。

例:

```js run
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

この構文の形式は、条件が真になるかどうかに関わらず、**少なくとも1度** はループ本体を実行したい場合を除き、ほとんど使われません。通常は他の形式が好まれます: `while(…) {…}`

## "for" ループ 

`for` ループは最も使われるものの1つです。

このようになります:

```js
for (begin; condition; step) {
  // ... loop body ...
}
```

例でこれらのパーツの意味を学びましょう。下のループは `0` から `3` まで(`3` は含みません)、`i` に対して `alert(i)` を実行します。:

```js run
for (let i = 0; i < 3; i++) { // 0, 次に 1, 次に 2 を表示
  alert(i);
}
```

`for` 文を部分的に調べてみましょう:

| パート  |          |                                                                            |
|-------|----------|----------------------------------------------------------------------------|
| begin | `i = 0`    | ループに入ると1度実行されます。     |
| condition | `i < 3`| すべてのループのイテレーションの前にチェックされます、もしも false の場合ループを停止します。       |
| step| `i++`      | 各イテレーションで、条件チェックの前に本体の後に実行されます。 |
| body | `alert(i)`| 条件が真の間繰り返し実行されます。         |

一般的なループアルゴリズムは次のように動作します:
```
begin を実行
→ (if condition → body を実行し step を実行)
→ (if condition → body を実行し step を実行)
→ (if condition → body を実行し step を実行)
→ ...
```

もし初めてループを使う場合は、上の例に戻って、紙の上でステップ毎にどのように動作するかを再現してみると理解しやすいでしょう。

これが今のケースで正確に起こっていることです:

```js
// for (let i = 0; i < 3; i++) alert(i)

// begin を実行
let i = 0
// if condition → body を実行し step を実行
if (i < 3) { alert(i); i++ }
// if condition → body を実行し step を実行
if (i < 3) { alert(i); i++ }
// if condition → body を実行し step を実行
if (i < 3) { alert(i); i++ }
// ...終わり, 今 i == 3 なので
```

````smart header="インライン変数宣言"
ここで "カウンタ" 変数 `i` はループの中で正しく宣言されます。それは "インライン" 変数宣言と呼ばれます。
このような変数はループの中でだけ見えます。

```js run
for (*!*let*/!* i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // エラー, そのような変数はありません
```

変数を宣言する代わりに、存在するもの使うことも出来ます:

```js run
let i = 0;

for (i = 0; i < 3; i++) { // 既存の変数を使用
  alert(i); // 0, 1, 2
}

alert(i); // 3, ループの外で宣言されているので見える
```

````


### 一部分の省略

`for` の任意の一部分を省略することができます。
例えば、ループの最初で何もする必要がなければ、`begin` を省略することができます。

このように:

```js run
let i = 0; // すでに i を宣言し代入済み

for (; i < 3; i++) { // "begin" 不要
  alert( i ); // 0, 1, 2
}
```

同じように `step` パートも除去することができます。:

```js run
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
```

ループは `while (i < 3)` と同じになりました。

実際にはすべてを除くこともできます。それは無限ループになります:

```js
for (;;) {
  // 制限なしで繰り返し
}
```

`for` の2つのセミコロン `;` は必須であることに注意してください。ない場合は構文エラーになります。

## ループの終わり 

通常、ループは条件が偽になると終了します。

しかし、いつでもループから出ることを強制することができます。そのための特別な `break` ディレクティブがあります。

例えば、以下のループはユーザに一連の数字を入力するよう求めますが、文字以外が入力されたとき "中断" します。:

```js
let sum = 0;

while (true) {

  let value = +prompt("Enter a number", '');

*!*
  if (!value) break; // (*)
*/!*

  sum += value;

}
alert( 'Sum: ' + sum );
```

もしもユーザが空を入力、もしくは入力をキャンセルした場合、`break` ディレクティブは行 `(*)` で有効になります。
それはループをすぐに停止し、ループ後の最初の行へ制御を渡します。つまり、`alert` です。

"必要に応じた無限ループ + `break`" の組み合わせは、ループの最初/最後ではなく、その間や本体の様々な場所で条件をチェックする必要がある状況で最適です。

## 次のイテレーションに進む 

`continue` ディレクティブは `break` の "軽量版" です。ループ全体はストップしません。その代わりに、現在のイテレーションを停止し、新しいイテレーションのスタートを強制します(もしも条件が真であれば)。

現在のイテレーションが完了し、次へ移動したいときに使います。

以下のループは奇数値だけを出力するために `continue` を使用しています:

```js run no-beautify
for (let i = 0; i < 10; i++) {

  // true の場合、本体の残りのパートをスキップ
  *!*if (i % 2 == 0) continue;*/!*

  alert(i); // 1, 次に 3, 5, 7, 9
}
```

`i` の値が偶数の場合、`continue` ディレクティブは本体の実行を停止し、`for` の次のイテレーションへ制御を渡します(次の番号で)。
したがって、`alert` は奇数値に対してのみ実行されます。

````smart header="ディレクティブ `continue` を使うと入れ子のレベルを減らせます"
奇数値を表示するループはこのように書くこともできます:

```js
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
```

技術的な観点からは、これは上の例と同じです。確かに、`continue` の代わりに `if` ブロックでコードをラップするだけです。

しかし、副作用として括弧のネストが1段深くなります。もしも `if` の中のコードが長い場合、全体の可読性が下がる可能性があります。
````

````warn header="`?` の右側には `break/continue` を入れないでください"
式ではない構文構造は、 `'?'` の中では使うことはできないことに注意してください。特に、ディレクティブ `break/continue` はそこでは許可されません。

例えば、このコードを考えます

```js
if (i > 5) {
  alert(i);
} else {
  continue;
}
```

...これを、疑問符を使って書き直します:

```js no-beautify
(i > 5) ? alert(i) : *!*continue*/!*; // continue はここでは使えません
```

...それは動作を停止します。このようなコードは構文エラーになります:


これは `if` の代わりに疑問符演算子 `'?'` を使用しない別の理由です。
````

## break/continue のためのラベル 

時々、複数のネストしたループから一度で抜け出す必要があることがあります。

例えば、下のコードでは 座標 `(i, j)` を `(0,0)` から `(3,3)` へプロンプトするよう `i` と `j` をループします:

```js run no-beautify
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // 仮にここで終了して下にある Done をしたい場合にはどうすればよいでしょう？

  }
}

alert('Done!');
```

ユーザが入力をキャンセルした場合、処理をストップする方法が必要です。

`input` の後の通常の `break` は内部ループのみの終了です。それだけでは十分ではありません。
ここでラベルが助けにきます。

*ラベル* は、ループの前のコロンがついた識別子です:
```js
labelName: for (...) {
  ...
}
```

ループの中の `break <labelName>` 文はラベルまで終了にします。

次のようになります:

```js run no-beautify
*!*outer:*/!* for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // 文字から文字またはキャンセルされた場合、両方のループから抜ける
    if (!input) *!*break outer*/!*; // (*)

    // 値に何かをする処理...
  }
}
alert('Done!');
```

上のコードで、`break outer` は `outer` と名付けされたラベルを上に探し、そのループを抜けます。

そのため、制御は `(*)` から `alert('Done!')` にまっすぐに進みます。

ラベルを別の行に移動させることもできます:

```js no-beautify
outer:
for (let i = 0; i < 3; i++) { ... }
```

`continue` ディレクティブもラベルと一緒に使うことができます。このケースでは、実行はラベル付けされたループの次のイテレーションにジャンプします。

````warn header="ラベルは \"goto\" ではありません"
ラベルはコードの任意の場所にジャンプすることはできません。

例えば、このようにすることは出来ません:
```js
break label;  // label にジャンプ? いいえ。

label: for (...)
```

`break/continue` の呼び出しはループの中からだけ可能です。またラベルはそのディレクティブから上のどこかにある必要があります。
````

## サマリ 

3つのループの種類について説明しました:

- `while` -- 条件は各イテレーションの前にチェックされます。
- `do..while` -- 条件は各イテレーションの後にチェックされます。
- `for (;;)` -- 条件は各イテレーションの前にチェックされ、追加の設定ができます。

"無限" ループを作るために、通常は `while(true)` 構造が使われます。このようなループは他の他のループと同様に `break` ディレクティブで停止することができます。

もしも現在のイテレーションで何もしたくなく、次のイテレーションに進みたい場合は、`continue` ディレクティブを使います。

`break/continue` はループの前のラベルをサポートします。ラベルは、ネストを抜けて外のループに行くための、 `break/continue` のための方法です。
